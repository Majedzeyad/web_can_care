
// src/Clerk/context/AppContext.jsx
import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';
import { subscribeToCollection, appAddDoc, appUpdateDoc, appDeleteDoc } from '../../services/firestoreService';

/* ---------- Helpers ---------- */
/**
 * Converts a Date object or date string to ISO date format (YYYY-MM-DD).
 * @param {Date|string} d - Date object or date string
 * @returns {string} ISO date string
 */
const toISO = (d) => (d instanceof Date ? d.toISOString().split('T')[0] : d);

/**
 * Generates a random ID with a given prefix.
 * Note: IDs are now generated by Firestore usually, but we keep this for temp logic if needed.
 * @param {string} prefix - Prefix for the ID
 * @returns {string} Generated ID string
 */
const genId = (prefix) => `${prefix}-${Math.random().toString(36).slice(2, 6).toUpperCase()}`;

/* Template slots per doctor (Configuration) */
const initialDoctorSlots = {
  'Dr. Omar Khaled': ['09:00 AM', '10:00 AM', '11:00 AM', '02:00 PM', '03:00 PM'],
  'Dr. Lina Yousef': ['10:00 AM', '11:00 AM', '01:00 PM', '02:00 PM', '04:00 PM'],
};

const AppContext = createContext(null);

/**
 * Custom hook to access the AppContext.
 * Provides access to all application data and CRUD operations.
 * @returns {Object} Context value with data and functions
 */
export const useApp = () => useContext(AppContext);

/* ---------- Provider ---------- */
/**
 * AppContext Provider component.
 * Manages application state including patients, doctors, nurses, and appointments.
 * Provides real-time synchronization with Firestore and CRUD operations.
 * @param {Object} props - Component props
 * @param {React.ReactNode} props.children - Child components
 * @returns {JSX.Element} Context provider with application data
 */
export const AppProvider = ({ children }) => {
  // State from Firestore
  const [patients, setPatients] = useState([]);
  const [doctors, setDoctors] = useState([]);
  const [nurses, setNurses] = useState([]);
  const [appointments, setAppointments] = useState([]);

  // Slots as config (could be moved to Firestore 'configs' collection later)
  const [doctorSlots] = useState(initialDoctorSlots);
  const [loading, setLoading] = useState(true);

  // Real-time subscriptions - استخدام collections الجديدة
  useEffect(() => {
    const { subscribeToWebAppointments } = require('../../services/firestoreService');
    
    const unsubs = [
      subscribeToCollection('patients', setPatients),
      subscribeToCollection('doctors', setDoctors),
      subscribeToCollection('nurses', setNurses),
      subscribeToWebAppointments(setAppointments), // استخدام web_appointments
    ];
    setLoading(false);
    return () => unsubs.forEach(u => u());
  }, []);

  // Fast lookups
  const patientById = useMemo(() => Object.fromEntries(patients.map(p => [p.id, p])), [patients]);
  const doctorById = useMemo(() => Object.fromEntries(doctors.map(d => [d.id, d])), [doctors]);
  const nurseById = useMemo(() => Object.fromEntries(nurses.map(n => [n.id, n])), [nurses]);

  // Availability helper (doctorId + dateISO) -> open slot names
  /**
   * Calculates available appointment slots for a specific doctor on a given date.
   * Uses workSchedule from doctor data, or falls back to default slots.
   * Filters out slots that are already booked in the 'appointments' list.
   * @param {string} doctorId - The ID or UID of the doctor.
   * @param {string|Date} dateISO - The date to check (string or Date object).
   * @returns {Array<string>} List of available time strings (e.g. "09:00").
   */
  const availableSlots = (doctorId, dateISO) => {
    // البحث عن الطبيب بواسطة id أو uid
    const doctor = doctorById[doctorId] || doctors.find(d => d.uid === doctorId || d.id === doctorId);
    if (!doctor) return [];

    // الحصول على اليوم من التاريخ
    const date = new Date(toISO(dateISO));
    const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    const dayName = dayNames[date.getDay()];

    // استخدام workSchedule من بيانات الطبيب
    let all = [];
    if (doctor.workSchedule && doctor.workSchedule[dayName] && doctor.workSchedule[dayName].enabled) {
      all = doctor.workSchedule[dayName].slots || [];
    } else {
      // Fallback: استخدام doctorSlots القديم
      all = doctorSlots[doctor.name] || [];
    }

    const dateStr = toISO(dateISO);
    const taken = appointments
      .filter(a => {
        // دعم كل من doctorId و uid
        const aDoctorId = a.doctorId || a.doctor?.uid || a.doctor?.id;
        return (aDoctorId === doctorId || aDoctorId === doctor.uid || aDoctorId === doctor.id) && 
               a.date === dateStr;
      })
      .map(a => a.time);
    
    return all.filter(s => !taken.includes(s));
  };

  // Double-booking guard
  /**
   * Checks if a proposed appointment clashes with an existing one.
   * @param {Object} param0 - Object containing { id, doctorId, date, time }.
   * @returns {boolean} True if a clash exists, false otherwise.
   */
  const willClash = ({ id, doctorId, date, time }) => {
    const dateStr = toISO(date);
    return appointments.some(a => {
      // دعم كل من doctorId و uid و name
      const aDoctorId = a.doctorId || a.doctor?.uid || a.doctor?.id;
      const checkDoctorId = doctorId;
      const doctor = doctors.find(d => d.id === doctorId || d.uid === doctorId);
      
      return (
        (aDoctorId === checkDoctorId || 
         aDoctorId === doctor?.uid || 
         aDoctorId === doctor?.id) && 
        a.date === dateStr && 
        a.time === time && 
        a.id !== id &&
        a.status !== 'cancelled' // تجاهل المواعيد الملغاة
      );
    });
  };

  /* ---------- CRUD (Async Firestore) ---------- */

  // Patients
  /** 
   * Creates a new patient in Firestore.
   * @param {Object} p - Patient data.
   */
  const addPatient = async (p) => {
    const { id, ...data } = p; // Let Firestore gen ID unless strictly p.id provided from elsewhere
    // If p.id exists and looks like temp, we strip it? 
    // The old logic was: setPatients([... { ...p, id: genId('P') } ])
    // Firestore adds ID automatically. 
    await appAddDoc('patients', data);
  };

  /**
   * Updates an existing patient record.
   * @param {Object} p - Patient data including ID.
   */
  const editPatient = async (p) => {
    await appUpdateDoc('patients', p.id, p);
  };

  /**
   * Deletes a patient record.
   * @param {string} id - Patient ID.
   */
  const deletePatient = async (id) => {
    await appDeleteDoc('patients', id);
  };

  // Doctors
  const addDoctor = async (d) => {
    const { id, ...data } = d;
    // استخدام createDoctor من firestoreService لإنشاء الهيكل الصحيح
    const { createDoctor } = await import('../../services/firestoreService');
    await createDoctor(data);
  };

  const editDoctor = async (d) => {
    await appUpdateDoc('doctors', d.id, d);
  };

  const deleteDoctor = async (id) => {
    await appDeleteDoc('doctors', id);
  };

  // Nurses
  const addNurse = async (n) => {
    const { id, ...data } = n;
    await appAddDoc('nurses', data);
  };

  const editNurse = async (n) => {
    await appUpdateDoc('nurses', n.id, n);
  };

  const deleteNurse = async (id) => {
    await appDeleteDoc('nurses', id);
  };

  // Appointments - استخدام web_appointments
  /**
   * Creates a new appointment after validating availability.
   * @param {Object} a - Appointment data.
   * @throws Will throw an error if the slot is double-booked.
   */
  const addAppointment = async (a) => {
    const { createWebAppointment } = await import('../../services/firestoreService');
    
    // Check clash against current local state (which reflects DB)
    if (willClash({ id: null, ...a })) {
      throw new Error('This slot is already booked for the selected doctor.');
    }

    // الحصول على بيانات الطبيب والمريض
    const doctor = doctors.find(d => d.id === a.doctorId || d.uid === a.doctorId || d.name === a.doctor);
    const patient = patients.find(p => p.id === a.patientId || p.name === a.patient);

    await createWebAppointment({
      patientId: patient?.id || a.patientId || null,
      patientName: patient?.name || a.patient || a.patientName,
      doctorId: doctor?.uid || doctor?.id || a.doctorId,
      doctorName: doctor?.name || a.doctor || a.doctorName,
      date: a.date,
      time: a.time,
      status: a.status || 'scheduled',
      notes: a.notes || ''
    });
  };

  /**
   * Updates an existing appointment.
   * @param {Object} a - Updated appointment data.
   * @throws Error if double-booked.
   */
  const editAppointment = async (a) => {
    const { updateWebAppointment } = await import('../../services/firestoreService');
    
    if (willClash(a)) throw new Error('This slot is already booked for the selected doctor.');
    
    // تحضير البيانات للتحديث
    const updates = {};
    if (a.doctorId || a.doctor) {
      const doctor = doctors.find(d => d.id === a.doctorId || d.uid === a.doctorId || d.name === a.doctor);
      if (doctor) {
        updates.doctorId = doctor.uid || doctor.id;
        updates.doctorName = doctor.name;
      }
    }
    if (a.patientId || a.patient) {
      const patient = patients.find(p => p.id === a.patientId || p.name === a.patient);
      if (patient) {
        updates.patientId = patient.id;
        updates.patientName = patient.name;
      }
    }
    if (a.date !== undefined) updates.date = a.date;
    if (a.time !== undefined) updates.time = a.time;
    if (a.status !== undefined) updates.status = a.status;
    if (a.notes !== undefined) updates.notes = a.notes;
    
    await updateWebAppointment(a.id, updates);
  };

  /**
   * Deletes (cancels) an appointment.
   * @param {string} id - Appointment ID.
   */
  const removeAppointment = async (id) => {
    const { deleteWebAppointment } = await import('../../services/firestoreService');
    await deleteWebAppointment(id);
  };

  const api = {
    // data
    patients, doctors, nurses, appointments, doctorSlots, loading,
    // lookups
    patientById, doctorById, nurseById,
    // helpers
    availableSlots, genId,
    // CRUD
    addPatient, editPatient, deletePatient,
    addDoctor, editDoctor, deleteDoctor,
    addNurse, editNurse, deleteNurse,
    addAppointment, editAppointment, removeAppointment,
  };

  if (loading) return <div>Loading Application Data...</div>;

  return <AppContext.Provider value={api}>{children}</AppContext.Provider>;
};
